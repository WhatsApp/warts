##
## This workflow factors out the core erlang/OTP build used to as the basis of
## various later CI jobs
##
name: Base build

on:
  workflow_call:
    inputs:
      base-branch:
        required: true
        type: string
    outputs:
      changes:
        description: "What apps were changed"
        value: ${{ jobs.pack.outputs.changes }}
      all:
        description: "All apps that exist"
        value: ${{ jobs.pack.outputs.all }}

env:
    BASE_BRANCH: ${{ inputs.base-branch }}

jobs:

  build:
    name: Build Erlang/OTP (64-bit) for subsequent stages
    runs-on: ubuntu-latest
    outputs:
        changes: ${{ steps.changes-override.outputs.changes }}
        all: ${{ steps.apps.outputs.all }}
    steps:
      - uses: actions/checkout@v3
      - name: Get applications
        id: apps
        run: |
          .github/scripts/path-filters.sh > .github/scripts/path-filters.yaml
          ALL_APPS=$(grep '^[a-z_]*:' .github/scripts/path-filters.yaml | sed 's/:.*$//')
          ALL_APPS=$(jq -n --arg inarr "${ALL_APPS}" '$inarr | split("\n")' | tr '\n' ' ')
          echo "all=${ALL_APPS}" >> $GITHUB_OUTPUT
      - uses: dorny/paths-filter@v2
        id: changes
        with:
          filters: .github/scripts/path-filters.yaml
      - if: ${{ github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'full-build-and-check') }}
        id: should-enable-full-build-and-check
        env:
            ALL_APPS: ${{ steps.apps.outputs.all }}
        run: |
          echo "enable-full-build-and-check=1" >> $GITHUB_ENV
      - name: Override changes
        id: changes-override
        env:
            ALL_APPS: ${{ steps.apps.outputs.all }}
            CHANGED_APPS: ${{ steps.changes.outputs.changes }}
        run: |
          if [[ enable-full-build-and-check ]]; then
              echo "changes=${ALL_APPS}" >> "$GITHUB_OUTPUT"
          else
              echo "changes=${CHANGED_APPS}" >> "$GITHUB_OUTPUT"
          fi
      - name: Create initial pre-release tar
        run: .github/scripts/init-pre-release.sh otp_archive.tar.gz
      - name: Upload source tar archive
        uses: actions/upload-artifact@v3
        with:
          name: otp_git_archive
          path: otp_archive.tar.gz
      - name: Docker login
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Cache BASE image
        uses: actions/cache@v3
        with:
            path: otp_docker_base.tar
            key: ${{ runner.os }}-${{ hashFiles('.github/dockerfiles/Dockerfile.ubuntu-base', '.github/scripts/build-base-image.sh') }}
      - name: Build BASE image
        run: .github/scripts/build-base-image.sh "${BASE_BRANCH}" 64-bit
      - name: Cache pre-built tar archives
        id: pre-built-cache
        uses: actions/cache@v3
        with:
            path: |
                otp_src.tar.gz
                otp_cache.tar.gz
            key: prebuilt-${{ github.ref_name }}-${{ github.sha }}
            restore-keys: |
                prebuilt-${{ github.base_ref }}-${{ github.event_name == 'pull_request' && github.event.pull_request.base.sha || github.sha }}
      - uses: dorny/paths-filter@v2
        id: cache
        with:
          filters: |
              no-cache:
                  - '.github/**'
              deleted:
                  - deleted: '**'
              bootstrap:
                  - 'bootstrap/**'
              configure:
                  - '**.ac'
                  - '**.in'
          list-files: shell
      - name: Restore from cache
        env:
            NO_CACHE: ${{ steps.cache.outputs.no-cache }}
            BOOTSTRAP: ${{ steps.cache.outputs.bootstrap }}
            CONFIGURE: ${{ steps.cache.outputs.configure }}
        run: |
            .github/scripts/restore-from-prebuilt.sh "`pwd`" \
              "`pwd`/.github/otp.tar.gz" \
              "`pwd`/otp_archive.tar.gz" \
              '${{ github.event_name }}' \
              '${{ steps.cache.outputs.deleted_files }}' \
              '${{ steps.changes.outputs.changes }}'
      - name: Upload restored cache
        uses: actions/upload-artifact@v3
        if: runner.debug == 1
        with:
          name: restored-cache
          path: .github/otp.tar.gz
      - name: Build image
        run: |
          docker build --tag otp \
            --build-arg MAKEFLAGS=-j$(($(nproc) + 2)) \
            --file ".github/dockerfiles/Dockerfile.64-bit" \
            .github/
      - name: Build pre-built tar archives
        run: |
          docker run -v $PWD:/github --entrypoint "" otp \
            scripts/build-otp-tar -o /github/otp_clean_src.tar.gz /github/otp_src.tar.gz -b /buildroot/otp/ /github/otp_src.tar.gz
      - name: Build cache
        run: |
          if [ -f otp_cache.tar.gz ]; then
            gunzip otp_cache.tar.gz
          else
            docker run -v $PWD:/github --entrypoint "" otp \
              bash -c 'cp ../otp_cache.tar /github/'
          fi
          docker run -v $PWD:/github --entrypoint "" otp \
            bash -c 'set -x; C_APPS=$(ls -d ./lib/*/c_src); find Makefile ./make ./erts ./bin/`erts/autoconf/config.guess` ./lib/erl_interface ./lib/jinterface ${C_APPS} `echo "${C_APPS}" | sed -e 's:c_src$:priv:'` -type f -newer README.md \! -name "*.beam" \! -path "*/doc/*" | xargs tar --transform "s:^./:otp/:" -uvf /github/otp_cache.tar'
          gzip otp_cache.tar
      - name: Upload pre-built tar archive
        uses: actions/upload-artifact@v3
        with:
          name: otp_prebuilt
          path: |
              otp_src.tar.gz
              otp_cache.tar.gz
